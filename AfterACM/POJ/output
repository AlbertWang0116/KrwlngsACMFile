commit 8561917437bbd4ee949168a00d78d53581a7b496
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 12 18:33:55 2013 +0800

    POJ 2406 - Power Strings
    
    Descryption: Check whther the string is formed by a^n, if it is, find the largest n.
    
    Solution: If it's a^n, then n%(n-ht[rk[0]])=0, where n is the size of original string. And n/(n-ht[rk[0]]) is the answer.
    
    Proof:
    1. If answer exists, there must be a sufix whose lcp with original string is the length of that sufix, i.e., s=a^x and s'=a^(x-1).
    
    2. The sufix is smaller than original string in sufix array.
    
    3. Assume the answer sufix is not the sa[rk[0]-1], but sa[rk[0]-y] (y>1).
    
    We let s1=sufix(sa[rk[0]-y]), s2=sufix(sa[rk[0]-y+1]), s=original string.
    
    We let |s1|=lcp(s, s1). Then lcp(s, s2)>=cur...(1) and lcp(s1, s2)>=cur...(2).
    
    Since (2),  sa[rk[0]-y+1] has the smaller index than sa[rk[0]-y].
    
    Let's denote Y=sa[rk[0]-y], Z=sa[rk[0]-y+1], b1=s[0..Z-1], b2=s[Z..Y-1], b=s[0..Y-1]. Thus b=b1|b2 and b^x'=s.
    
    From the definition ,we get s1=b^(x'-1), s2=b2|b^(x'-1). From (2), we get b^(x'-1) = b2|b^(x'-2)|b1 ----> (b1|b2)^(x'-1) = (b2|b1)^(x'-1) ----> b1|b2 = b2|b1 = b...(3)
    
    From (3), we get lcp(b, b2)=|b2|...(4)
    
    From (3), (4), we get lcp(s=b^x'=b^(x'-1)|b, s2=b^(x'-1)|b2) = |s2|...(5)
    
    From (5), we can infer that for all 0<=i<=y, lcp(s, sufix(sa[rk[0]-i])) = |sufix(sa[rk[0]-i])|. i.e., if I is the factor of n, it has longer repeatetion than Y.
    
    That is, if the answer is Y, |b1| is not the factor of n. Since |b| is the factor of n, thus |b1|, |b2| is not the factor of |b|.
    
    Denote p=|b|/|b1|, q=|b|%|b1|<>0, r=b[|b|-q...|b|-1].
    
    Since b1|b2=b2|b1=b. lcp(b=b1|b2, b2)=|b2|. Thus b[x]=b2[x]=b[x+|b1|](x+|b1|<|b|) ----> b=b1^p|r.
    
    Since b1|b2=b2|b1=b. lcs(b=b2|b1, b2)=|b2|. Thus b[x]=b2[x]=b[x-|b1|](x-|b1|>=0)  ----> b=r|b1^p.
    
    Let's denote c1=r, c2=b1^p. We get b=c1|c2=c2|c1.
    
    Repeat the above operation, and finally we get b=*1|*2=*2|*1 where |*1| is the factor of |b|. s*=*2|b^(x'-1) must be the sufix between s2 and s (since lcp(s, s*)=|s*| and the start index is smaller than s2). In addition, |*1| is the factor of |b|, thus it's the factor of n, and s=*1^x" (x">x').
    
    Finally, it contradict with the assumption that the answer is sufix(sa[rk[0]-y]) where y>1.
    
    Status: TLE - since the O(nlogn) sufix array is too costy. However, the proof above can also use in the KMP and LSA to get the answer.

commit de9b79966f6519d76fcfb46731c714435c0bcb65
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Sep 11 21:14:14 2013 +0800

    POJ 3581 - Sequence
    
    Description: Given a string, split it into 3 consecutive subsequence, reverse each subsequence. To get the smallest result.
    
    Solution:
    Let S be the original string, S' be the reverse of S. The first subsequence mustbe the smallest sufix of S', since S[0]>S[1],S[2],...,S[n-1](It indicate that each sufix is different before end of the sufix).
    
    Now the problem becomes to split a string into 2 consecutive substring, reverse each subsequence and get the smallest result. (Since the first subsequence is confirmed). Let s be the original string of S-(first subsequence), and s' be the reverse of s. The reverse of second and third subsequence can form the minimum notation of s' (illustrate the procedure and one can get it.).
    
    Status:
    First WA : Forgot to reverse the string when calculate the sufix array.
    
    Second WA : The original solution is wrong. The original is, to get the second subsequence, just find another smallest sufix whose index is before the start of first sufix in S'. It's wrong because the end character of second subsequence is not unique, and it's next character in result string is the first character of S'. one case indicate this is "5 0 2 1 2 1 3", the wrong solution is 0 5 1 2 3 1 2, but the correct answer is 0 5 1 2 1 2 3. But this solution still indicate a inference in sufix array: After we find the smallest sufix and cut it away, the smaller sufix in orginal sufix array is still smaller in remainder (Use contradiction to prove it). Thus we don't need to get the sufix array in remainder again.
    
    AC.

commit e8534ab63853e3c9a71b32c41828a535e468fd01
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Sep 10 18:03:53 2013 +0800

    POJ 2758 - Checking the Text
    
    Desctription: An initial length 50000 string. At most 200 insertion (one character each), at most 20000 query. The query is to find the lcp of two sufix.
    
    Solution: Since the insertion is at most 200, we can split the query into at most rmq (The match based on sufix array will be blocked at the insertion point). Thus we need to construct tags to indicate the insertion point, the latest insertion point from the query point, etc.
    
    Status: 1. WA first - When insertion, it should be guaranteed that the bidirectional reflection between original string position and current string position is correct. I forgot to give the initial value of the reflection from new inserted character, which interupt the original string.
    	2. AC

commit 6d274f37063417953791e03bb284acbfd7abca77
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Sep 10 00:35:11 2013 +0800

    POJ 3623 - Best Cow Line, Gold
    
    Solution: For the remainder line, if the normal order is larger than revert order, choose the front initial, otherwise choose the last initial.
    Hint: The greedy scan can also solve this problem in O(n) time.
    State: AC in first submit.

commit 3d06ef2c2fc6db0edb42cf49fdab8b6d1fd04f38
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Sep 6 21:21:02 2013 +0800

    POJ 3693 - Maximum repetition substring
    
    The detail solution will be posted later. The proof is very long. (Using segment tree to optimize and the number theory to prove the correctness).

commit 83fb850f0b5578cda7a1b3be1b570147483d1b9e
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Aug 16 19:49:46 2013 +0800

    POJ3261 - Milk Patterns
    Problem: Find the longest common substring which occurs k times.
    
    Algorithm: Check all the consecutive k-1 elements in the SA array.
    
    No Wrong Submit.

commit c149b8de5a9c11f5a9b330bfa5f80492ee5973c8
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Aug 15 21:40:01 2013 +0800

    Change User Name.

commit 8a4439fa32a8c5442986f461b254ce7a6b8da5e5
Author: pdsp <pdsp@vmdemo.localdomain>
Date:   Thu Aug 15 21:21:21 2013 +0800

    [Normal]POJ1743 - Musical Theme
    The longest non-overlapping common prefix.
    
    Algorithm: Get the SA array and Height array. Then use the dichotomy on result. The judgement step is like this: For each i, find largest j make rmq(i, j)>=result (It means Height[j+1]<result). If max(sa[i..j])-min(sa[i..j]) no less than result, the result is valid and answer may bigger. Or continue finding next interval, start at j+1 (think why).
    
    Special Process in this problem: For the judging result R, the valid interval is rmq(i, j)>=R-1, the valid max(sa[i..j])-min(sa[i..j]) is R (think why).
    
    Wrong Submit:
    1). The special case n=1
    
    2). In my code, the ineterval is [i, j). But my next start is i=j+1.
    
    3). Forgot to return 0 if no valid result find.

commit eeebdc227657e0dc62fd313a777b9010b2c766dc
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Sep 22 18:25:47 2012 +0800

    Two problems in number theory
    1.POJ 1845 - Sumdiv
    Tag: euler function, euler theory
    Description: given to integer A and B, return the sum of all natrual divisors of A^B.
    Solution: Based on theory, if a number X can be described by (p1^r1)*(p2^r2)*...*(pk^rk), the sum of all natrual divisors can be described as (p1^0+p1^1+...+p1^r1)*(p2^0+p2^1+...+p2^r2)*...*(pk^0+pk^1+...+pk^rk). Another optimization is, we only need to calculate the sum of first I element for pi, where I=0, 1, 2, ..., 9900. Because from euler theory, we can know the pi^9900=pi^0=1(mod 9901).
    
    2.POJ 2115 - C Looooooops
    Tag: extend oclidean algorithm
    Description: Calculate the smallest positive integer k, so that (a+c*k)%(2^k) = b.
    Solution: its the result of congruence modulus equation c=b-a(mod 2^k).

commit 913908a7019d508f8c6fe5ce715c86d090303850
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 20 23:48:33 2012 +0800

    two problems about Number Theory:
    1) POJ 2635 - The Embarrassed Cryptographer
    tag: prime sift, high-precision module
    description: given a large number k (k<=10^100), and it's guaranteed that k is the product of two prime. The goal is to check whether the smaller prime is smaller than another given number L(L<=10^6).
    solution: sift the prime list first. then use k module all the prime which is smaller than L. note that the large number k should be stored in at least thousand-decimal to avoid the TLE.
    
    2)POJ 3292 - Semi-prime H-numbers
    tag: prime sift
    description: find out all the semi-prime h-numbers decripted in the problem.
    solution: we can see the h-number as the normal number, then we find the prime. In the prime sift process, once we find a prime, we times the prime and others we found before. Obviously, they're all semi-prime h-numbers. Then we get the answer.

commit ccecc3a267dea5e74d90c3149fc12b21d6b84820
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 20 17:39:02 2012 +0800

    Temporary Update

commit 15a2571dcd8c62bc52a746c7605c573dcb9e8fc5
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Dec 4 20:22:55 2011 +0800

    1.CodeForces Round 95 Division 2
    1).proA - cAPS lOCK
    A mixed meaning problem of implementation. If the format of given string is in the certain condition, transform the whole string.
    2).proB - Opposites Attract
    Hash problem. find the number of pair that v1 = -v2. A trick: 0 cannot be the partner of itself.
    3).proC - The World is a Theatre
    Recurrence problem. let f[i] be the number of condition that boys is exactly i(4 <= i < t). ignore the condition of i > n and t-i > m.
    4).proD - Yet Another Task with Queens
    The pair of queens who are the neighbour in the same line/column/diagonal line are threaten each other. it canbe exactly found by using sort in line/column/diagonal line order. Total time is O(nlogn).
    
    2.CodeForces Round 96 Division 1
    1).proA - Turning Tape
    Another mixed meaning problem of implementation. Reverse the previous letter in binary format as the key(0 as the result of first calculation), minuse the reverse of the current letter. result will be added by 256 if it's negative.
    2).proC - Logo Turtle
    A simple dp problem. Let f[i][j][k] to be the i-th step using j times reversation, and the orintation is k(0 for backward and 1 for forward). f[i][j][k] can contribute to (f[i+1][j][k] and f[i+1][j+1][1-k]) or (f[i+1][j][1-k] and f[i+1][j+1][k]). The answer is the best one for f[n][j][k], where m-j is even.
    dp for two times. first time start at f[0][0][0] = 0. second time start at f[0][0][1] = 0.
    3).proD - Constants in the language of Shakespeare
    Greedy algorithm.
    the first time combine the consecutive '1' together(if i..j is 1, we can using +2^(j+1) and -2^i to archive the goal).
    the second time we combine the two neighbour consecutive unit the previous step get if the distance of the tail of previous and the head of latter is 1 and not both are a single 1.(if i..j and j+2..k is in the condition, we can using +2^(k+1), -2^(j+1) and -2^i to archive the goal). The combined unit in this step can be combined to other unit again.
    then we count the rest unit, if it's only constructed by a single 1, just count it by one. else count it by the number of tiniest units added by 1. and the way to output it is easy(told before).
    My fault in the contest: I firstly didn't combine the unit at following condition in step 2: the distance of two units is 1, but one of the unit is constructed by a single 1. The truth is, combine the unit won't let the answer worse, and may let it optimized. examples below:
    111010111 -> combined will let it optimized.
    11101 -> combined won't let it be worse.
    
    3.Computational Geometry in POJ
    POJ3432 - Count Squares
    Find the number of squares that the vertexes is exactly on the given point. Using hash map and enum the edge of square. O(N^2*logN).
    POJ3512 - Incidental Points
    Find a line wich go across maximum number of given points. enum each point and find the optimized set which has maximum number of points who are in the same orientation to the base point. the answer is the number of largest set. Be careful with condition that multi points in the same position. O(N^2*logN).
    
    4.TopCoder SRM 525 Division 1
    proA - DropCoins
    A implementation.Given a grid and some coins in the integer point, and the left, right, upper, low bound of the rectangle. for all the sub-rectangle, which has the property of the distance of the left bound and the root's left bound dl, the distance between the right bound and the root's right bound, the distance between the upper bound and root's upper bound du, the distance between the low bound and the root's low bound, the number of coins in the sub-rectangle dk. find a sub-rectangle whose dk equals given k and let the (min(dl,dr)+min(du,dl))*2+(max(dl,dr)+max(du,dl)) be minimum.
    proB - Rumor
    Enum the strategy of each rabit when it first get a rumor(0 or 1). If all the rabits who lastly get the first rumor can get both rumor, return the number of the day. Otherwise output the number of the day + 1.
    My fault in contest: I firstly only enum the strategy of the start vertex(who initially know the rumor), and the wrong case is as follow:
    1->3->
           5->6->7
    2->4->
    1,2 is the start vertex. The answer is 6(day+1), but only count the strategy of start point can get the answer of 5(day).

commit c6dd7d1b1d9177be8fd22a9915046dac20b8f111
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Nov 27 23:16:53 2011 +0800

    1.Some Computational Geometry Problems in POJ
    1)POJ2653 - Pick-up sticks
    Using map to store the valid segment. When new segment comming, delete the segments that become invalid. Totallt, simulation.
    2)POJ2780 - Linearity
    Find a line that intersects as many points as possible.
    STL map has large constant time, sort is recomended.
    the linear enum(n*n*logn) is recomended, O(n*n*log(n^2)) will TLE.
    3)POJ2954 - Triangle
    Find the number of points which has inter coordinate and inside the given triangle. Naked Pick Theorem.
    4)POJ2957 - Planet Hunting
    Rotate points to make the center of three points is the same, then calculate it.
    5)POJ3335 - Rotating Scoreboard
    Given the points of the polygon, check if there exists a core. Naked Half Plane.
    Though the problem another bug of the model of hfplane has been checked out, and it has been fixed.
    6)POJ3304 - Segments
    Check if there exists a line that go through all the given segments. enum two points and validation(O(n^3)) can already handle the problem. But there's an O(n^2) method -- enum the endpoint of segments to be the point the line must go through and calculate the valid angle of the line to pass through all the segments.
    Trick for O(n^3) method: some endpoints is same and the pair has the same coordinate cannot form a line.
    7)POJ3348 - Cows
    Simply construct a convex and calculate the area of it.
    
    2.CodeForces Round95 Division 2
    The Page is error, so the log will be added next weekend.

commit 001b9ef0fb17a8d375f01236421216395f4ca4e8
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Nov 15 21:19:05 2011 +0800

    1.CodeForces Round 94 Division 2
    proA - Cookies
    Given a sequence. If the sum of the sequence is even, then return the number of the even numbers in sequence. Otherwise return the number of odd numbers.
    
    proB - Students and Shoelaces
    Simulation. Each round find out all the exist vertices which has only one edge connect to it. Then erase all the points and the edge connect to it. The round stopped when there's no such kind of point. return the count of the round. since the number of vertices is at most 100, simulate the process of it is enough.
    
    proC - Status
    BFS. Find the valid position player can both reach and valid, and use it to calculate the next turns position. If the player can reach the up-right or can exist after 8 rounds, the player wins. Otherwise the status wins.
    
    proE - Games with Rectangle.
    Since the internal rectangle is exactly inside the outer rectangle. The width of each rectangle is exactly one inside its outer, so does the height. so we can count how much ways to set k segment in a segment of length n, and reduce the O(N^3) to O(N^2).
    The state is f[i][j], length i and j segments. There's an optimazation that the f[i][j] can express as f[i-1][j]+(f[i-2][j-1]+f[i-3][j-1]+...+f[1][j-1]). set sum[i][j] = f[i-2][j]+f[i-3][j]+...+f[1][j]. then sum[i][j] = sum[i-1][j]+f[i][j]. so f[i][j] = f[i-1][j]+sum[i-2][j-1]. Notice at the border: f[i][0]=1(i>0).
    
    HDU1849 - Rabbit and Grass
    A naking Nim Game.
    
    HDU2188 - A naking Bash Game
    
    HDU2897 - Xie Hou Ming Xia
    Another naking Bash Game. (n-1)%(a+b)+1 <= a then first player lose.
    
    HDU1851 - A Simple Game
    The using of SG-Function. The SG value of each pile is n%(m+1).
    
    POJ2505 - A multiplication Game
    Pair of win/lose interval
    floor1: fst:(1,9) snd:(9,18)
    floor2: fst:(18,162) snd:(162, 324)
    ...
    floori: fst:(18^(i-1), 18^(i-1)*9) snd:(18^(i-1)*9, 18^i)
    
    when n is at the floor-i's the fst position. A can choose a number n1 to make n/n1 to the floor-(i-1)'s snd position(or win imediatly). From then on, whatever parameter B choose, A can always get a number to make n/mul-tot stay at the some floor's snd place until floor1. and after B's next move, A will win whatever B moves.
    For the same reason, if n is at the floor-i's snd position, it can always be kept after both player moving. So B will win the game.

commit 0b0375c7f7c93ff3b76da08b8f1fd986bbea5d48
Author: Albert <st.krwlng@gmail.com>
Date:   Mon Nov 14 22:01:38 2011 +0800

    From now on I'll make the log format easier to view.
    
    1.Recontest the training contest of bjtu.
    p1001 - Clear All of Them I
    DP. using 2^20 to save the state. when come to a state i, using lowbit to get its first point doesn't get matched. Enum the other point to match with it and update the former state if it has a optimizing result. The answer of the problem must be the f[2^20-1].
    
    p1002 - Clear All of Them II
    Hasn't solved in the contest. Simulation and DP. It's easier than the p1001. Every time use the spfa to get the valid four points and update the answer.
    
    p1004 - Invoker
    Polya thorem.
    
    p1005 - Extended-Tree(Unsolved)
    construct a three-children tree in the i-th sequence. Divide and conquer.
    
    p1006 - Substring
    given two integer a(<= 10^100) and b(<= 10^7), check the minimum addition for a to contain a sunstring of b.
    if a <= b, the answer is obviously b-a.
    otherwise, enum the position of the occurence in a of b(fron len(b) to len(a)+1, if b=0, stop at len(a)).
    for each enum, the compare b with the next len(b) digits start from position i:
    if it's larger than b, then add 1 to the position in a higher than i by 1. set the digits after substring b in a to 0.
    otherwise if it's smaller than b, simply set the digits after substring b in a to 0.
    if it's equals b, then output the answer 0 imediatlly.
    
    p1007 - Hand in hand
    simple problem. because the vertice has no more than two edge, the gragh only can made up by some circle and chain. if the type of chain and circle in two gragh are same, it's valid.
    
    p1008 - Math Geek
    There's a expression to construct the anti magic square. But in this problem, the random algorithm to swap two position is enough.
    
    2.Two problems in same type of game theory
    Beijing 2008 Regional/UVA Liva-Archive 4323 - a simple stone game
    Firstly, we should check out if a position is a P-position. We start out in solve out serveral cases for k=5.
    	for all the k<=5 it's must be the P-position.
    	p=6	-> P
    	p=7	-> N
    	p=8	-> P
    	p=9	-> N
    	p=10	-> P
    	p=11	-> N
    	p=12	-> P
    	p=13,14 -> N
    	p=15	-> P
    	p=16,17	-> N
    	p=18	-> P
    	p=19,20,21	-> N
    	p=22	-> P
    	p=23,24,25,26	-> N
    	p=27	-> P
    	p=28,29,30,31,32	-> N
    	p=33	-> P
    	p=34,35,36,37,38,39,40(2+),41 -> N; p=40(1) -> P
    	p=42	-> P
    	p=43,44,45,46,47,48(2+),49,50(2+),51	-> N; p=48(1),50(1)	-> P
    	k=52	-> P
    	p=53,54,55,56,57,58(2+),59,60(2+),61,62(2+),63	-> N; p=58(1),60(1),62(1)	-> P
    	p=64	-> P
    	p=65,66,67,68,69,70(2+),71,72(2+),73,74(2+),75,76(3+),77,78,79	-> N; p=70(1),72(1),74(1),76(2)	-> P
    
    From the data above that, we can infer that:
    1). If a postion can go to the P postion in the safe step(the next player cannot using previous steps to get to the terminal), the position is a N-position.
    2). Additionally, we can find there're several positions that will become P-postion if the previous step is equal or smaller than a certain number. Because though it can reach the P postion in safe steps, but there're not enough steps to reach it, and it cannot reach another postions of this kind. We defininate this kind of postion small P-position. note that small P-position is not a lose state for the frist player. Moreover, besides the postions that can reach the P-postion within one safe steps, some positions can firstly reach the small P-postion and gradually get the P-postion. See p=41 as an example. It cannot reach 33 within safe step, but it can go to 40 first, because 40(1) is a small P-position.
    
    If we can find all the N-postion and small P-postions after a P postion, the next P postion must just after them. The N-postion of first type is easy to determine, but how to get the postions for the type two. We can transfer the problem to such child problem: we must get to the P-postion at last, then we see P-postion's new index is 0, and we're now at n-P-postion. We can step forward for (P-postion-1)/k steps for the first move to ensure the next player cannot step to the real terminal. At this point, the problem f(n) is divided to the problem f(n-P-postion). As the result, what's the next P-postion after the current P-postion? we can find that the postion NXT - P-postion must be exactly the index of P-postion after (P-postion-1)/k. Because it's the first postion that after the (P-postion-1)/k and cannot go to the last small P-position within (P-postion-1)/k. As the result, p[i+1] = p[i]+p[next[i]]. next[i] is the P index of the first P-postion that bigger than (p[i]-1)/k.
    
    We have already infered that the lose state can only happen at P-postion other than small P-postion, so the first problem has solved.
    
    Secondly, if it's not the P-postion, how can we find the smallest step?
    It's become easy when we get the conclusion above. We can divide f(n) to f(n-(P-postion)) easily noted by f(n1). If n1 is not the P-postion, it's obvious that it's not the small P-postion in the last function(f(n)), then it can be divided further(to n2, n3, ...). If it comes to the condition that ni is P-postion, it must be a small P-position for the f(n[i-1]). So it must step forward to ni steps, to reach its nearest small P-postion.(If n1 is P-position, it's a small P-position initially, and must step to the really P-position only). The problem then solved.
    
    -------------END-----------------
    
    HDU2516 - Stone game
    A more eaier game in the same theory with the problem above, where k is always 2 and only need to check if the first player will win.

commit 53024fa35f8dd18fc10cc31e5f365907d2e0ed6d
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Nov 13 14:44:18 2011 +0800

    Add the last version of format model

commit 566ef53e6fc37361e1d47e937e80aa664042378a
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Nov 13 14:37:36 2011 +0800

    Modified the module for 2 tricks and add the trick data.

commit fd544b2232025f16d88bfd384d23863ce2882acd
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Nov 13 02:42:00 2011 +0800

    complete the Model!

commit cd27cdeb324f1fa7cd8eb3d89cb44c61be7df4cf
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Nov 11 20:53:11 2011 +0800

    CodeForces 39B -- an easy problem. get the longest subsequence of a given sequence which the value of first index is 1, the value of second index is 2 ...
    CodeForces Round40 Div2 ProC -- a construction problem. The condition of n=1, n=2 and n=3 is special condition. For n is even, let its index is 0, 1, 2, ..., n-1. Firstly, connect the point i to i+1(n-1 to 0). Then connect 0 to 3, 5, 7, ..., n-3; 1 to 4, 6, 8, ..., n-2... The way of connection must be valid, and each point has (n-4)/2 inter-line to connect out. So the total number of this kind of line is (n-4)/2 * n / 2. And the answer of this kind of gragh has completed. If the n is odd, construct the gragh of n-1, and let the n-th point connect to 0, 2, 4, ..., n-2. So there's another (n-1)/2 lines connect in.
    CodeForces Beta Round13 ProC -- given a sequence. get the least number of edit to make the sequence the non-decreasing sequence. let f[i][j] to be the meaning that edit a[i] to the value of j-th smallest number in the sequence, and garantee the first i subsequence is non-decreasing, the least number of operation. obviously, f[i][j] = min(f[i][j+1], f[i][j+2], ..., f[i][n]) + abs(a[i]-a[seq[j]]). It's the O(n^3) algorithm, but the former expression can be ignored and the total time can be optimized to O(n^2), because the f[i][j+1] is also need min(f[i][j+1], ..., f[i][n]). There's even O(n) algorithm for this problem, using drab queue.
    CodeForces Round93 Div2 proA -- given a set of segment(p1->p2, p2->p3, ..., pn-1->pn). get the value of the total length of the segment.
    CodeForces Round93 Div2 proB -- given a sequence. get the most number of pairs which has the same value.(an element can be counted only once) the answer is that value divides 2 rounded down.
    CodeForces Round93 Div2 proC -- enum full of trick. if t0 equals t1 and t0 equals t2, then let x1=maximun and x2=maximum. Otherwise if one of them equals t0, let it be maximum and the other be 0. If it's not the former condition, enum the value of y1 from 0 to maximum, and calculate the best y2 for each y1 using expression. Then do the same operation with y2 firstly.
    CodeForces Round93 Div2 proD -- find a substring, which is the prefix, suffix and another substring, which is neither of its prefix and suffix, of the string. Using suffix array, the O(nlogn) will get TLE, only O(n) can be accepted.
    CodeForces Round93 Div2 proE -- a construction problem. The state of the first row and column can only be determined by the strategy its self and can be easy checked out. After it, the strategy of second line and colunm can be determined too, because only the first line and colunm and itself can determin it. And so on...
    CodeForces Round93 Div1 proD -- a recurrence problem. find the largest value in fibonacci sequence which is smaller than the given n, save its index in the array seq[1]. then the next largest index to seq[2], seq[3], ... Suppose that we have a fibonacci number of f[i]. It can be divided into f[i-1] and f[i-2]. If we want to divide the f[i] to the sum of some different number in f, we can't divide the f[i-1] now. Because f[i-1] will be divide into f[i-2] and f[i-3] and there's an extra f[i-2]! Then divide the extra f[i-2] to f[i-3] and f[i-4] ... There always has an extra number. So we can only divide the f[i-2] initially for the next strategy. For the same reason, if the given n is the sum of f[i] and f[j](f[j]<f[i]). The smallest divide of f[i] can not be small than f[j], i.e, there's a f[k] comes from the divide of f[i], the k must no less than j. And there's a constraint for the condition that k equals j, i.e, j has been divided(k still cannot be divided because j-1 will always be there). As the result, there's an initial sequence seq whose sum is n, and seq is seq[1], seq[2], seq[3], ..., seq[m].(seq[1]>seq[2]>seq[3]>...>seq[m]) seq[1] cannot divide across the seq[2], so dose seq[2], seq[3] ... seq[m]. and each interval of divide can be distinct, so we can get the answer by the recurrence calculation. Let the f1[i] to be the number of way to divides the first i subsequence, and the j is not be divided. And let the f2[i] to be the number of way to divides the first i subsequence with the j has been divided(The latter condition may allow the i-th interval has another divide). Add a number 1 after the end of the seq as the border. And the answer will be f2[m].

commit b514763c1cbdf4370c56b5b5d5d530061db81852
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Nov 11 08:25:07 2011 +0800

    HDU1730 -- after the model transition. it's obvious to be a Nim Game.
    POJ1082 -- recurrence is already enough to solve this problem. But there's a regular pattern. Let S to be the sum of day and month. if S is even, there must be a strategy to make the next sum of day and month to be odd(and avoid the special day of 9.30 and 11.30). If the day is odd and not the sepcial day, it has no strategy to make the next day and month to be the odd. The terminal station is odd. As the result, if S is even or it's the sepcial day, the first player will win the game.
    POJ2234 -- the meaning has already told that it's the Nim Game.
    POJ1067 -- the Wethoff Game, the proof will be taken on the notebook.
    POJ1704 -- after the model transition. it's a Stair-case Nim Game. only count the pile of odd index to take in the Nim Game.
    POJ1740 -- Game with no model. Take all the pair which has the same number of stones out of the game, if there is still any piles of stones, the first player will win. Otherwise the second player will win. (Because if there's any piles not in the pair, the first step can achieve the condition that there're only many pairs of the same number of the stone.)

commit 8579988d0e224f5d4adc7ce7f5613c3a83c38d55
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Nov 9 22:05:30 2011 +0800

    CodeForces Round08 Beta ProC -- the DP described two days before. I used lowbit function to get the next strategy for a state, and using link to make a state saved at the postion it should be handled at the first point(using map to index the postion).
    CodeForces Round33 Beta ProC -- easy DP. s[i] = s[i-1]+a[i], f[i] = min(f[i-1], s[i]). then enum the start point of the suffix, the ans = max(ans, s[i]-2*f[i]-sum(suffix)). it's no need to make suffix and prefix go across each other because their intersection keeps the original after to operation.
    CodeForces Round46 DIV2 proB -- easy multi number system problem. get the largest digit, and the best number system is that digit+1. Then calculate the answer by that number system.
    CodeForces Round55 DIV2 proC -- A problem with many trick. the condition of impossible: 1.the str[i] and its mirror is not the same(they're both not '?'[trick.1]). 2.the str[i] is a letter >= 'a'+m.(and not the '?'[trick.2]) 3.the number of the mirror pair that are both '?' is small than the number of letter which are not used[trick.3]. other comment:1)if there's only one '?' on one side, change it to another's value. 2)as the greedy requirement, if the number of mirror pair[?] is larger than the number of letters, which is not used now, at the smaller index of the left side, fill the pairs with 'a'.
    CodeForces Round76 DIV1 proA -- Many conditions. 1) if the number of row is 1, or the start point is at the leftmost of a row and the end point is at the rightmost of another row, operations is 1; 2).If the number of row is 2 and has no condition in 1), the operations is 2; 3). If 1) and 2) are not in the condition, and the index of the row for startpoint is st, the index of the endpoint at its row is ed. if st is leftmost or ed is rightmost or ed+1=st, the number of operations is 2; 4) the other conditons are or 3 operations. Trick: if the endpoint is the last one of the item, count it as the rightmost of its index(hard to notice it).
    HDU4116 -- Chengdu Regional ProF. Find a line to go across the most number of given n circle. it's obvious that there must exist at least one such line which is the tangent line of two circle. enum the first circle from 1 to n, and do the angle sweepline algorithm, maintain the number of circles the tangent line now cross. The total time for it is n^2logn(at most 4n^2log(4n)). Caution: for the condition that a circle is in another, ignore the smaller one when deal with the big one, and let the line always corss the bigger one when deal with the smaller one, the answer must be get. Extended: Find a circle which contains the most number of given n points.
    POJ2318 -- dichotomy. find the first segment the points is on the right side of it.
    POJ2546 -- calculate the intersection of two circle.(the sphere of the same problem has already solved) see the notice at the notbook.

commit 8981a5c5e49c4ce2ea72029fc5b50b608aa3cb77
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Nov 8 22:39:40 2011 +0800

    POJ2208 -- given the length of 6 edges of a triangular pyramid, calculate the volume of it. the expression can be searched online.
    POJ2354 -- given two postion by coordinate on earth(in latitude and longitude), calculate the surface distance of sphere for the two points.
    Modeling problems: SG game for Laker's Nim Game, CodeForces Beta 13 ProC(DP, with 2^24 states and 24 strategy).

commit df6af853c03f80fdd50a532d4f5cc1259c366ce3
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Nov 8 08:45:29 2011 +0800

    Beta 03 - proC - The simulation with many trick. The sequence of the answer is illegal, first win, second win, draw, first, second. There're four conditions for illegal:1).'x'-'o' > 1 or 'x'-'o' < 0. 2). both first and second are winner. 3). first win but now is first player's turn. 4). second win but now is second player's turn.
    Round 09 - DIV2 - proA - simulation. if the total time is no more than current answer, then replace it.
    Round 18 - DIV2 - proA - simulation. find whether the triangle is a right triangle by move it by 1 unit. trick: 3 points are on the same line or 2 points are at the same position.
    Round 69 - DIV1 - proA - enum. find the every condition that has the least distance for exp and at the previous condition the most value for teamwork.
    Round 79 - DIV1 - proA - greedy. the fewer number of the same letter comes former to delete.
    Beta 88 - proC - dfs and incremental method. firstly find a circle(the length of circle must be more than 3 because no two pairs connect each other) using dfs. Then find any three vertex. if they form a circle, the answer is get. Otherwise delete the middle point and find another vertex in the circle. There must be an answer in the circle because for the worst condition, the circle at last will be deleted at length 3.
    POJ2007 - simple problem. Only to construct a convex for the given N points. In the output, the point (0, 0) should come first.

commit eb601e84335877bb4ba46a8439777aa8ff193a9e
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Nov 5 22:45:21 2011 +0800

    1.complete the model that the intersection of the circle and convex, but still need optimized.
    2.POJ1981 -- find a position of a unit circle to cover most number of points. method: enum every two points to set up the circle and the best one is among them. O(N^3).

commit bf6827a65ac99358adb07c9d86de78076a3c493c
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Nov 4 00:58:47 2011 +0800

    Many Codeforces problems.
    1.R80 DIV2
        proA -- print list. known the initial number and find the ways of another to make up of the given number.
        proB -- recurrence or simulation. find the number of steps for the given strategy to walk from left to right.
        proC -- the original problem is to check if there're a set of three or more rooted trees whose roots are connected by a circle. after the transformation, it's to check if the gragh is connected and has only one circle(number of vertex is equal to number of edge).
        proD -- construction. there're 3 situations. 1).n >= 2k and n-2k is even. the best answer for this is ..(...).X.X.X(...) 2).n >= 2k and n-2k is odd. the best answer for this is ..(...).X.X.X(...).XX 3).n < 2k, the best string is .X.X.X(...).XXXXXX(...). trick:if number of X is zero and the number of . is odd, the last postion for this algorithm is X, you know how to solve this.
        proE -- as the range of data is 3*10^5. divide it into two condition for a request. 1). bi <= 500. save it into a list[bi]. after all req conducted, for every b<=500 dp to get all the answer of request whose b = bi, and save it. 2). bi > 500. brute force.
    2.R92 DIV2
        proA -- brute force. get the min of n-a and b+1.
        proB -- brute force. the range of data is small. so enum all the permutations and check the minimum answer.
        proD -- CG. convert the two point to the index of square it's in, and the answer is max(abs(r1-r2),abs(c1-c2)). trick:if (x+y)<0 then the row of its square is (x+y)/2a-1, so dose it's column.

commit 537d9f74e3399ed0e86650f87e4dad3499b7ddb7
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Nov 2 23:26:48 2011 +0800

    HDU3932 -- a obvious smallest enclosing circle for N given points. Using the problem to constrct the model for the same algorithm.
    HDU3882->CS and Sugar -- DP. f[i][j][k] = max(val[i][j]-max(f[i-1][j][k+1], f[i][j-1][k+1]), max(f[i-1][j][k], f[i][j-1][k])). if (k>abs(val[i][j])) no previous expresion in outer max().
    HDU3903->Trigonometric Function -- cosA, cosB, cosC must be rational(Cosinelaw). if cosa is rational, so is cos(na). if sina is rational, so is sin(na).(mathmetical induction). As the result, the problem is to prove sina is rational(using Sinelaw).

commit 0d6028d3b42fcdac17679459ceea68b0aafcca67
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Nov 2 01:47:27 2011 +0800

    1.Many new model has been updated.
    2.Some computational geometry problems.
        HDU1007 -- the nearest pair in 2D plane.
        HDU3982 -- two algorithms are refered to. 1) half plane, and the error in model of half plane is found through this problem. 2) the intersection of a circle and a convex. The part 2 has many details and it's better to construct a model to solve this kind of problem.
        POJ1971 -- find the number of parallelogram whose endpoints are given points. The midpoint compare can avoid the precision problem( double can only express no more than 10 effective digit. )
        UVA->Rujia Liu's Prensent 4->proL -- find the all-pair farthest points. The algorithm will be described in notebook, and the model of it will be constructed.

commit bbc4d0a396b093663c5316881ef1c944ef5fd8dc
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Oct 19 21:50:44 2011 +0800

    1.3 easy problems in CodeForces R85DIV2.
         proA, DIV2 -- compare 2 strings igoring the case(upper case is as same as the lower case).
         proB, DIV2 -- check a given cell is at the center of the square.
         proC, DIV2 -- check if (m-k+1)^2+k is larger than or equal to n.
    2.2 easy geometry problems in POJ.
         1859 -- check if a set of points is point symmetry. sort the set in x increasing(if x same, y increasing) order. if there exists a symmetry point, the pair of points which has the same ditance to the middle of sequence have the common middle point.
         1927 -- calculate the maximum area in a triangle area by known perimeter of the former area. it can be certificated that r/R = (C-L)/(C-CR). see at my notebook.
    3.complete the model of check the point in polygon(verify it by ZOJ1081).

commit 82c9f600d2a22b619133ce2f5d586c0cbc7e8305
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Oct 18 23:53:31 2011 +0800

    1.UVA1269 -- simple arithmetic problem. calulate the area of triangle for known edge.
    2.proD, Rujia Liu's CG Contest -- 3D Geometry Transformation using matrix.
    3.The module of 3D Geometry Transformation using matrix, and some basic opeartion of plane.
    4.ProJ, Today's Codeforces Contest -- A nearest pair in plane.

commit 314008ac6bb978f4bdad4305790484fa43a6251a
Author: Albert <st.krwlng@gmail.com>
Date:   Mon Oct 17 21:04:49 2011 +0800

    Complete CondeForces Round 84(except last problem of DIV1)
        proA,div2 -- simple implementation. count if the number of 4 and 7 is 4 or 7.
        proB.div2 -- times for modeling. output the loop string abcdabcd... of length n.
        proC.div2 -- find the least total number of 4 and 7 which is added up to n. as the n <= 10^6, brute force does already work. Extended Euclid can solve much larger range.
        proD.div2 -- 3 hours to solve ... discretize the range to interval. calculate the sum of each match interval.
        proE.div2 -- tree dp. find the number of nodes the node x can reach after passing a lucky edge. firstly calculate the number of its subnode which is valid, and others in the second dfs.
        proD.div1 -- complete the operation of replacement group through swap method. The detail about this operation I have put down at note-book.

commit 16b880355e92edf24ae123bb6cfca8146aa49de8
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Oct 16 00:20:41 2011 +0800

    1.Orlando World Final ProA -- We can split the formula into the format that st*M^(i-1)+a1*A*M^(i-1)+a2*A*M^(i-2)+...+ai*A(parameter i is the number of operation M minus 1, so i >= 1). We can see a1*A*M^(i-1)+a2*A*M^(i-2)+...+ai as the same as the number of A, which is converted into M number system and have i bits, in the conditon that A is operated after all the M. To make the answer shortest, the value of bit 0 ~ bit i-2 must no more than M-1, because M bit k-1 can convert into bit k, which is shorter. As the result, if we know the number of operation M, we can get the range number of the operation of A in the condition that A is operated after all the M, convert them to the i bits of M number system, and choose the best answer where T = a1+a2+a3+...+ai is the least. The least number of total operation for i M operations is T+i, and we can get best answer by enuming the every valid i. If M = 1, there's no need to do any M operations. Else M >= 2. To make the stl*M^(i-1) <= edr, the number of i is no more than 31(2^30 > 10^9). So there's only O(B^2) times calculation, where(B <= 31).
    2.Topcoder SRM521 DIV1 P500 (DIV2 P1000) -- Algorithm: 1.Add the border point at leftup, leftdown, rightup, rightdown. 2.dsicretize the sets to make the whole coordinate as griding. 3.For each sub grid of the whole grid, if the width and height of grid is larger than nlow, find out all the points strictly in the sub grid. Make the set of the points as S. If the width and height of S is smaller than nhigh as well as the width and height of sub grid, S is one of the answer. Caution: the same set may be found out many times. Suffcient proof: the point must lay on the cross point of the grid. As the result, for any valid subset of P, a square can be drawed. extend the square until the side would reach the horizontal or verticle line of the grid(square must in the grid beacuse of 4 border points). the extended rectangle contains the same cross points of the grid as the non-extended square, so as the subset of P. The rectangle, as the one of the sub grid, can get that subset of P. So all the subset of P can be found though all the sub grid.

commit 91f2ea4c508ed4b48465f4c57797b5960337c6d8
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Oct 13 21:18:17 2011 +0800

    1.Oct 11th. Orlando World Final.
        proK -- find the least width of a polygon. simple use of rotate caliper.
        proE -- given a points set. find a diamond shaped area to contain most points, no more than 20 questions. rotate the coordinate for 45 degree to convert the problem to change the diamond to square, and it becomes a simple dp. The code is wrong and waiting to solved.
    2.Topcoder SRM 511 DIV2.
         250 -- Easy simulation. Do as the problem says.
         500 -- count the number of occurence of each number. if the occurence of i+1 is larger than i or the occurence for any i is larger than 2, it's impossible. the answer is (1 << number of 2 occurence + (there's no less than 1 time of 1 occurence ? 1 : 0 )).
        1000 -- Didn't solve by now. the solution says it's a dp problem. the state is f[i][j], where i means the mem and j means the number of cards used. waiting to be solved.
    3.Shanghai Regional Warming Up.
        1001 -- Many precision problems. The aim is to find the smallest enclosing circle, but the center of circle must on a given line. Trichotomy is right but always WA maybe the precision problem(compare with my AC program using the random data there's no problem, so I don't know why). Another solution is random and incremental algorithm. If a temp circle is a smallest enclosing circle and the next point is in it, the circle is still the temp answer. If not, the coming point must be one of the two point which determine the next temp answer. Another point can also be found by the same way. The average time of the method is O(n).
        1002 -- Simple simulation. If the operation is DROP, drop it to tile 2. If not, take the tile 1, and if it's not enough, move all the plates of tile2 to the empty tile 1 and take the left. operation will no more than 4N and 4M.
        1007 -- The smallest distance must come from a endpoint of seg or startpoint. So the problem can be converted to a dijkstra. But before it is a initialization, or there must be a validation to judge if point a can go to point b straightly. for each point in init, if it can't reach seg i, neither can seg i+1. So record the angle region for the orientation it can reach the seg, and we can calculate the next region rely on it. If the angle is smaller than 0, this startpoint cannot go farmore. If the angle region is go across a endpoint of that seg, the startpoint can reach that endpoint. At last, the answer is the smallest distance from all the points which can reach the last seg. To calculate the distance, the angle region is useful.
    4.Topcoder SRM 521 DIV!.
         250 -- simple problem. To add the least parentheses to make the express match.
         500 -- Using the square of the size from nlow to nhigh, find the number of subsets of P which can be enclosed by these square. A condition is valid only the points in subset is in the square and others must not. Didn't solve yet.
    Left porblems to be solved --> --- proA, World Final 2011; --- 1000, DIV2, SRM511; --- 500, DIV1, SRM521.

commit ac4b57855ee071830c93ef42ded70101efa0c549
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Oct 11 00:24:20 2011 +0800

    2 problems about rotate axis. modified a stretch rotate method which can rotate the v1 to v2 for both angle and length, and get the coordinate of a point whose initial coordinate is given.
        POJ1133 -- a much detail problem. find the number of combination of given n points which can be constrcted to be similar to a given polygon. enum each edge of pair of n points as the first edge of the polygon, and get the other point(by using stretch_rotate method).
        TOJ3740 -- 2010 Tianjing Online Contest proC. given n points and find a enclosing square whose each edge has at least ont point on it. Special Judge. Note that a proper rotate matching the condition must has the width-height == 0. We can also infer that the sign of (width-height) in 0 dgree rotate is differ from one in 90 dgree rotate. So dichotomy can get one of the solution.

commit 731c10509236c461199e851099b94575e1ecb601
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Oct 9 23:28:39 2011 +0800

    1. 4 problems in Colimbian Programming Contest
        proJ -- simple greedy algorithm. at first I use the dp method but get wrong answer for 2 hours! I still don't know what gonna wrong, but the greedy algorithm takes the same time as the dp method.
        proI -- dp problem. at first I didn't notice that the range of value is small so that dp for one time takes only 720*100 calculation, and do the sweepline optimized by segment tree(takes N*log(L) calculation, where N = 10k, L = 100). TLE it till the end of contest.
        proH -- the only problem takes no more than 1 hour in the contest. easy sweep line problem.
        proG -- another greedy problem. discretization first.
        be careful of Thinking Set. proH is waited to be done, which is a 3D geometry problem.
    2. 2 problems about rotate axis in 2D geometry
        HDU1700 -- basic rotate problem. rotate for 2 times to get the answer.
        POJ3845 -- a bit harder problem for iterator. for each steps, get the start point and end point, the rate of segment first, and then get the segment of next step
    within the extended segment, using the rotate function for assistance.
    3. optimize the code of rotate function to be brevity, and add another interface of the rotate function.

commit 7252570c9b12a047f586f15cba353442966d6a49
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Oct 8 21:32:29 2011 +0800

    1.Oct 6th - Solved a dp problem(Harbin Final ProC - UVA1092). The major difficulty of it is discretilization. I has writen down the tip about it.
    2.Oct 7th - Solved a cg problem(Fuzhou Regional Online Contest ProC - HDU4063). Using the circlecrs used in Rujia Liu's Present4 and the segxcircle used in Dalian Regional. Some optimization is improtant, such as ignore the condition of internal cross or tangent.
    3.Oct 8th - Complete the module of the axis rotate in 3D geometry. The trial will be carry out tomorrow:)

commit 60e0b2a5e48c2893a3ffc28f84317efadeee6c94
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Oct 6 00:32:30 2011 +0800

    1. 2 problems in the geometry special in UVA 3 days before.
        proE --> completed the last 2 problems. there's no need to add eps before output the answer, or WA recieved.
        proH --> a simplified method have been worked out, and the length of code has been shorten more than half. the model has been constructed in geometry section 3.
    2. finish the geometry model refer to the problems solved several days before, especially some improtant points in triangle. The operation of circle conducted these days is not modeled because there's not much use by now. Mark them now and they'll be modeled in the future if the problems about them are meet again.

commit bdc7131776cab6331e67a60903e7b6902f8289e2
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Oct 5 00:59:03 2011 +0800

    A geometry problem in Dalian Regional Contest.
        proH(ZOJ3546) --> if the point is in the polygon, return 0.00. if the point is on the right side of the left bound, the polygon may reach it by rotate to right. vise virsa. make rotating to right as the condition. firstly make the convex and calculate every angle to rotate and the offset before it. If the distance from the point to the right bound is larger than the length of rotating aniverse, then move it the latter length to left a time until the condition is false. and enum every edge, rotate it for an aniverse or as soon as it reach the LP point. the method to check whether in a rotate the segment can reach the point is as following: the distance from a point in the segment to the origin would not change in the rotating. As the result find the point which has the same distance to the origin as the LP point, and if it rotate pass through the angle the origin to the LP point(since the rotate always make the angle smaller, if the angle of point on seg is initially no smaller than the LP point's and the angle of destination is no larger than it, then the point rotate across hte LP point), then the segment must rotate across the LP point, the rotate angle can also be solved out. return the smallest angle a segment reach it. it must be the first time the polygon reach the LP point.
    Topcoder SRM 520 DIV1. Only solved the 250 problem. The method of 500 problem has thought out but no time to code it.
        250 --> enum the problem to solve. if the total time is larger than 75+luck, the condition is impossible. else distribute the luck points to the larger problem, because it can bring more score back. return the condition of largest points.

commit 80ce283cedb302077081208092e0c7f80029438a
Author: Albert <st.krwlng@gmail.com>
Date:   Mon Oct 3 23:40:32 2011 +0800

    1. Complete SRM512 DIV2.
        250 --> Simple problem. find the snd largest number, and the answer will be snd+min(largest number, snd+1).
        500 --> Simple recursion. find the least cost for the i-th day of the week for first j week. then answer will be found.
        1000 --> A obvious KM problem. copied model to solve it.
    2. Two simple problems in Dalian Regional Contest.
        proD/ZOJ3542 --> simple simulation. caution the condition that the length mod 16 equals 0.
        proE/ZOJ3543 --> Recursion. let the state f[i][j] be the i-th number is the j-th least number in first i subsequences. if str[i-1] is 'I', f[i][j] = f[i-1][1]+f[i-1][2]+...+f[i-1][j-1]. if str[i-1] is 'D', f[i][j] = f[i-1][j]+f[i-1][j+1]+...+f[i-1][i-1]. if str[i-1] is '?', f[i][j] is the total of f[i][k](k = 1->i-1).

commit e730b5accdc91bba14d8519b4998e7c8a55964d2
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Oct 2 00:42:17 2011 +0800

    Mainly solved 4 problems in Rujia Liu's contest.
       proA --> given the distance of the farthest pair of vertexes and calculate the area of n edges regular polygom. simple problem about cosine theorem.
       proB --> given a classical plain geometry problem. using the sine theorem to solve it. note that the "Multiple solution" is never appears.
       proC --> nine points circle. But it's is very easy to solve because the circle can get by any three of them, and problem has already tell that there must be a solution.
       proH --> use of rotate calliper to get the smallest enclosing rectangle in either perimeter or area. I use the complex and usual coding, and during it I found there exists a easier way, later I'll try it.
       proE --> calculation about circle. more complex than proC. I have completed 4 of 6. generally it must be done 5 minutes for each in contest. But...
    Morning have I solved another geometry problem in Multi School Contest - ECNU
       p1003 --> find whether a polygon is axisymmetric. find out the core of the polygon. every pair of symmetrical points must has the same distance to the core.

commit 2e450d3ac814651a3712dad1102229d7ef58731d
Author: Albert <st.krwlng@gmail.com>
Date:   Fri Sep 30 22:34:31 2011 +0800

    1.another problems using SA method
        poj2069 --> find a minimum sphere to contain all the points(<= 30). distribute new points equably will WA. fixed step leads AC. NA.
        poj3285 --> find a point which have the common angular diameter(r/dis) with 3 circle. 1).use variance as the evaluation function. 2).dis/r is better than r/dis. 3).It's more likely to AC that limit the range of answer(though the answer may be out of range, the possiblity is very low). 4).fixed step is better than equal distribution.
    2.three simple problems of computaitional geometry.
        poj1654 --> simple problem to calculate the area of a polygon. 1A. 10min.
        poj1673 --> find the orthocenter of a triangle(The meaning of the problem didn't tell it straitly). be careful again when output float number, the result should add eps to avoid -0.00! 5A. 30min.
        poj1696 --> find the path when meet corner, the orientation is always left. the use of xmul. Too much time to debug. 1A. 20min.
    3.SRM514 and 515(DIV2)
        SRM514 --> 250 --> simple geometry. find the shortest distance to reach a rectangle. 10min.
                   500 --> simple map search. check whether are there some way to jump from st to ed using some kinds of k-knights jump. Too much time to code and debug. 1A. 40min.
                  1000 --> recurrence problem. find the number of '1' from st to ed of a 01 string which comes from the self-replicating of some strings. 2A. 70min.
        SRM513 --> 250 --> simple matrix calculation. given the attendance of students(people->knowledge) and requirements of problems(problem->knowledge), output the expect of the result in matrix(people->problem). 20min. 1A.
                   500 --> interval operation. there're some points in a segment where one cannot settle the board across it. given some board with their length and a position which it must contain(distinct for each). find the number of way to postion them. 2A. 40min.
    	      1000 --> enumeration. distribute a 4x4 board, to make the sum of combination of consecutive number maximum. 2A. 60min.
        All of the above take more than 90min to solve all the problems because of the low speed of modeling, coding and debug. The ability of them should be practise more!

commit 400dd13f56a76b07b1beb1621cd0cfe60a225233
Author: Albert <st.krwlng@gmail.com>
Date:   Wed Sep 28 23:47:47 2011 +0800

    Learning the SA method and complete two simple SA problems.
        poj2420 --> find a point which has the least total distance to all the given points. 1A.
        poj1379 --> find a point which has the most distance to the nearest point. 2A. be careful with the -0.00.
        yesterday --> be careful that 0x7f to the int is 127, to the memory is 0x7f7f7f7f.

commit b9e3da4cdea0f6bc51b22debef2eda5cc57ac373
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Sep 27 23:15:31 2011 +0800

    Solving 6 problems of Topcoder SRM DIV2 as well as a problem in poj about easy halfplane.
        SRM517-DIV2 --> 1000 --> sort and DP. 50min.
        SRM516-DIV2 --> 250  --> find the first character which is not '?'. the i-th character is same with this character if the distance to this character is even. vise virsa.
    		    500  --> to a plaintext, if it can find as the same way as the 1st ciphertext to last ciphertext through the plaintexts, it can be the plaintext to the 1st ciphertext. It must be the only key because distinct plaintext has different result to have operation XOR with 1st ciphertext.
    		    1000 --> an easy problem of topological sort.
        SRM515-DIV2 --> 250  --> easy enumeration. Using hash table to record repeat.
    		    500  --> using hour record to determine the minutes, and the angle between minite hand and 00:00 position, then get the hour position. Becareful with the condition that the value of hour position out of range(both < 0 and >= 360 are possible).
        POJ1474     --> a easier half plane problem, only horizental and vertical segments exist.

commit fd5f6a4e8153d172cade82cf9ab3e2d5571fd296
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Sep 27 12:47:29 2011 +0800

    Three easy problems of computational geometry
        poj1389 --> calculate the total area of serveral rectangle. Sweepline. 1A. 45min.
        poj1410 --> check whether a segment has a common point with a rectangle. 1WA, ignoring the condition the segment is already in the rectangle totally. 2WA, misunderstand the discription that the border isn't given in order. 3A. 40min.
        poj1473 --> get the distance between startpoint and endpoint with serveral connected segment path. 1WA, fail to handled the input. 2A. 30min.

commit 596371b847ca4d125410368431bea7dc1459f50f
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 22 09:13:49 2011 +0800

    1.Complete the module Ver 0.1.
    2.HDU3692 -- a simple 3D dimensional geometry problem.

commit 20ea285c4594027d90da433afb390919498c56d9
Author: Albert <st.krwlng@gmail.com>
Date:   Tue Sep 20 13:06:40 2011 +0800

    1. Add the module of rotate-caliper and the problem in use of the algorithm.(HDU3834 & POJ2079)
    2. HDU3881 --- sort with the index of the aim orientation, the answer must be the angle between two adjacent points. Becareful with the condition that more than three points in a line, and the nummul and submul is forbidden because of the region of data, the rotate of axis is recommended.
    3. The module of line intersection with O((n+m)logn) still have some problems to handle.

commit 6b65208ea1afbc494a4d1542164b7278789ae9b6
Author: Albert <st.krwlng@gmail.com>
Date:   Sun Sep 11 23:44:53 2011 +0800

    Add the problems solved in online contest of Shanghai(Sept.10th) and Chengdu(Sept.11th)
    	Shanghai-p1005 -> Dichotomy. The maximun range of the shoot can get anyway, and if the time shooter can success at the max range, the time later than it can also get it(because of the constraint of lx*lx+ly*ly<vd*vd<vb*vb).
    	Shanghai-p1010 -> Choose every three of the points, get the time that they form a line, and check the number of points at that line at the same time. be caution at the condition that two even three points at the same position.
    	Chengdu-p1003  -> Dichotomy. divide the cos value of the first two edge, and the cos value and the actual angle. If the sum of the angle is smaller than 2pi, the divided cos value must be bigger than the actual value, vise versa. if the final value is not -1 or 1 and the polygon formed finally is legal(the angle of each adjust edge is equal), the answer is legal, else it's not.

commit 6d18c5d33c15134ff1292e232b529b074f5fa92f
Merge: 23a783e 429f913
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Sep 10 12:29:00 2011 +0800

    Merge branch 'master' of github.com:MissAmour/KrwlngsACMFile

commit 23a783e8f163adcb0c1f23bcc2c302a86a85419d
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Sep 10 12:27:32 2011 +0800

    Add the Shanghai Contest

commit 429f913699bd01b75384d3f5ff290282337598cb
Author: Albert <st.krwlng@gmail.com>
Date:   Sat Sep 10 11:44:08 2011 +0800

    Sept.8th -- The problem about multi school contest 3
    	 -> HDU3861: tarjan and the maximum binary graph match
    	 -> HDU3862: an simple theory of plain geometry
    	 -> HDU3867: the sweepline for angle, using map to maintain the state
    	 -> HDU3868: the extended use of the nearest two point in plain. Note that if an better answer of value d' exists, the distance of every two points of it is smaller -
    		     than the half of the previous answer d, which is d/2.

commit 260fd0fb2e8320d51c3f4bc8132eb8ce5e36b472
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 8 12:47:16 2011 +0800

    Add the code and module editted before Sept.8th

commit 8b9c8e119e25696f70ebcd5609cfa02688bf688d
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 8 12:40:52 2011 +0800

    Delete the material because of the size

commit 8020f0195afcb4c70166191d24863858e2117248
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 8 09:46:48 2011 +0800

    Nothing important

commit 92d9085df71c89e9757fcca58b288c376f6f48ba
Author: Albert <st.krwlng@gmail.com>
Date:   Thu Sep 8 09:38:01 2011 +0800

    first edtion: Add the material and programs before 2011
