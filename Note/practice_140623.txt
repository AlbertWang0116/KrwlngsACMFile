*6.23
TopCoder SRM625 DIV-1 600pt
问题描述：提供一棵树，有n个节点（n<=30)。现有k种颜色(k<=30)，一个节点选择某种颜色花费的代价为a[i]。现要求每个节点选择2种不同的颜色，并满足条件：任选一个节点，令它和它的所有子节点各染上它们选择的颜色的其中一个，不存在重复的颜色。
解法：树形DP+最小费用流（用于决策）。
首先进行特判，若某个节点的子节点个数大于等于k，则一定无解。f[i][j]表示节点i选择颜色j作为和它子节点进行颜色测试选择的颜色。
f[i][j]可通过费用流得到：1)除源汇点外有3层节点，第一层代表每个子节点，第二层有k个节点，第三层有k-1个节点。2)源点连向所有第一层节点，流量1，费用0. 3)第一层的每个节点u连向第二层每个节点v，流量为1，费用为f[u][v]。4)第二层每个节点i’连向第三每个节点j’(j’!=j)，流量1，若i’=j’则费用为a[0]，否则费用为a[j’]。5) 第三层每个节点连向汇点，流量1，费用0.
最终的f[i][j]值为最小费用流的值加上a[j]。
最终的最优结果为最小的f[0][x]加上a[0]。
证明：
1）每一条合法的最大流都是f[i][j]的一个决策。每一个f[i][j]的决策也是当前图的一个最大流。
2）基于费用流决策的正确性，用数学归纳法证明树形dp的正确性。

*6.24
CodeForces Round253 DIV-1 proA
问题描述：有5种花色和5种数字大小的牌。现有该类牌N张，背面朝上。但是玩家知道每一种牌（25种之一）各有几张。现有一种提示操作：指定一种花色或大小，并提示玩家哪些牌是这种花色和大小。问最少提示多少次玩家能分清所有牌的种类。
解法：枚举+同集合归类。
枚举提示方式。对于每种提示方式，将所有N个牌归类，共归为6*6类，表示该张牌是某种已知的花色（5种）或未知花色，是某种已知的大小（5种）或未知大小。若该提示方式可以使36种归类的每种归类的不同种类牌的数量不多于1，则该提示是有效的。
证明：对于同一归类的不同种类的牌（该归类一定存在至少一项未知），未知项不存在更多的信息加以分辨，因此提示无效。

CodeForces Round253 DIV-1 proB
问题描述：有N个概率(N<=100)。选取任意个，使得恰好发生1个概率事件的概率最大。
解法：对N个概率进行排序。最优解一定是某个值k，最大的k个(k>=1)事件同时发生。
证明：
1) 若存在的事件刚好发生一个概率为P，都不发生概率为Q。现加入一个独立的概率为x的事件，则刚好发生一个事件的概率为f(x)=P*(1-x)+Q*x。对其求导得到f’(x)=Q-P。当x=0时f(x)=P，x=1时f(x)=Q。因此若Q>P，f(x)线性递增;否则线性递减。
2) 若存在的事件刚好发生一个概率为P，都不发生概率为Q，且0<P<Q。则不存在概率p，使得该事件加入后，f(p)>0.5且f(p)>=p。
	A. 当p=0.5时，f(p)=(P+Q)/2<=0.5。
	B. f’(p)=Q-P<Q+P<=1.0=p’。
	由A和f(p)线性递增，f(p)>0.5当且仅当p>0.5。又由A和B，当p>0.5时，f(p)<p。因此结论成立。
3) 若存在一个事件概率p>0.5，则该事件加入任意一个事件集合都不是最优解。
	若事件集合P>Q，则f(p)<f(0)=P。若事件集合P<Q，则根据结论(2)，f(p)<p。
4) 若事件集合是最优解，但其组成事件并不是发生概率最大的k个。将组成事件中概率最小的事件i移除得到新的组成事件P和Q。一定有P<Q，否则该组成事件比所谓最优解更优，因为加入移除事件导致f(pi)<f(0)=P（由1）。由于存在不在新组成事件中得事件j且有pj>pi。因此一定有f(pj)>f(pi)。因此找到了更优的k个事件集合。
综上所述，由(4)可知最优解一定是概率最大的k个事件集合。
备注：结论(2)和(3)是探究结论(4)时得到的附加结论。

*6.25
TopCoder SRM618 DIV-1 500pt
题意：给出要求字串的种数：1) 字符串含有n种字符。2) 字符串不含有连续的相同字符。3) 子串（可不连续）不含有ABAB或AAAA形式(两个相同字符之间的其他字符不可出现在区间之外，且相同字符最多只出现3次）。4) 字符串不可再加入任何字符，使得新串合法。
解法：DP。f[i]表示i种字符的构造组合数，则f[i]=f[i-1](情况B)+sigma[j=1->i-2](f[j]*f[i-1-j])(情况A)。
证明：
1）一个字符串合法的必要条件是不能再在任意位置插入任意字符得到一个新的合法字符串。满足该必要条件的字符串形式有：
	A) 字符串两端末尾都是字符x，且字符串中间还有一个字符x。前两个x中间夹着含有i个字符的合法字符串，后两个x	中间夹着含有j个字符的合法字符串。i+j=n-1。（反证法）
	B) 字符串两端末尾都是字符x，两个x中间夹着含有n-1种字符的(A)型和(B)型合法字符串。（反证法）
	C) 含有m段(A)型合法字符串的串联，每段合法字符串含有a[i]种字符，a[1]+a[2]+…+a[m]=n。（反证法）
	备注：
		1.1) 若B类型夹的是n-1种字符的C型字符串，则一定能在C型字符串的连续两段之间插入一个x，使得整		个字符串变成一个A型合法字符串。
		1.2) 若C类型某一段是B型字符串，则可以在整个字符串末尾再增加一个该段尾端的字符得到一个更长的		合法字符串。
		1.3）若是其他类型的字符串，若端点不符合上述3个类型，则可以添加端点字符达到更长的字串。若否，		则一定是某个被夹的子串不属于上述类型，递归进入子串找到不合法的端点，则可增长。
2）含有n种字符的合法字符串最长为2n-1，其中类型A和B可以达到该长度，所有C类型不可。
2.1) 当n=1时，有且仅有一个B类型的字符串x。
2.2) 若n=k-1时公式合法，则当n=k时
	A) f[k]=3+f[i]+f[j]=3+2(i+j)-2=3+2(n-1)-2=2n-1.
	B) f[k]=2+f[n-1]=2+2(n-1)-1=2n-1.
	C) f[k]=f[a[1]]+f[a[2]]+…+f[a[m]]=2(a[1]+a[2]+…+a[m])-m=2n-m<2n-1.
综上所述，存在长度2n-1的合法字符串，且都为A和B类型。因此该问题只要求得所有A和B类型的字符串即为答案。

*7.1
CodeForces Round245 DIV-1 proD
题意：一个长度为n的数列a(n<=10^5)。现定义f[i, j]=(i-j)^2+sum(a[i+1..j])^2。求f[i, j]最小值（i!=j)。
解法：最近点对。p(i)=(i, sum(a[1..i]))。f[i, j]=dist(pi, pj)^2。

*7.3
TopCoder SRM626 DIV-1 600pt
题意：一个复杂图G, V<=50, E<=2500。现要求从节点1到达节点N的最小代价，且存在一种操作，当某一次经过某条边时，代价为该边权值的相反数，该操作可执行X<=10^9次。
解法：floyd+倍增。f[i][j]为执行0次操作从i到j的最小代价。g[i][j][k]为执行2^k次操作，从i到j的最小代价。则g[i][j][0]=min(f[i][x]+f[y][j]-largest_E[x][y])；g[i][j][k]=min(g[i][x][k-1]+g[x][j][k-1])。